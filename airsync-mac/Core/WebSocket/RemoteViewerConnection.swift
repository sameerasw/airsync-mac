//
//  RemoteViewerConnection.swift
//  
//
//  Created by Generated by AI.
//

import Foundation
import Network
#if canImport(AppKit)
import AppKit
#endif

public final class RemoteViewerConnection {
    
    /// Called on main thread when a new frame (image) is received and decoded successfully.
    @MainActor
    public var onFrameReceived: ((NSImage) -> Void)?
    
    private var connection: NWConnection?
    private let receiveQueue = DispatchQueue(label: "remote-viewer.receive.queue")
    private let sendQueue = DispatchQueue(label: "remote-viewer.send.queue")
    
    private var isConnecting = false
    private var isConnected = false
    
    // Maximum allowed frame payload size (20 MB)
    private let maxPayloadSize = 20 * 1024 * 1024
    
    public init() { }
    
    deinit {
        disconnect()
    }
    
    /// Connect to the given host and port.
    public func connect(to host: String, port: UInt16) {
        sendQueue.async { [weak self] in
            guard let self = self else { return }
            if self.isConnected || self.isConnecting {
                print("[remote-viewer] Already connected or connecting")
                return
            }
            self.isConnecting = true
            print("[remote-viewer] Connecting to \(host):\(port)...")
            let nwEndpoint = NWEndpoint.Host(host)
            let nwPort = NWEndpoint.Port(rawValue: port)!
            let connection = NWConnection(host: nwEndpoint, port: nwPort, using: .tcp)
            self.connection = connection
            
            connection.stateUpdateHandler = { [weak self] newState in
                guard let self = self else { return }
                switch newState {
                case .ready:
                    print("[remote-viewer] Connection ready")
                    self.isConnecting = false
                    self.isConnected = true
                    self.receiveLoop()
                case .failed(let error):
                    print("[remote-viewer] Connection failed: \(error.localizedDescription)")
                    self.isConnecting = false
                    self.isConnected = false
                    self.cleanupConnection()
                case .waiting(let error):
                    print("[remote-viewer] Connection waiting: \(error.localizedDescription)")
                case .cancelled:
                    print("[remote-viewer] Connection cancelled")
                    self.isConnecting = false
                    self.isConnected = false
                    self.cleanupConnection()
                default:
                    break
                }
            }
            
            connection.start(queue: self.receiveQueue)
        }
    }
    
    /// Disconnect the current connection and clean up.
    public func disconnect() {
        sendQueue.async { [weak self] in
            guard let self = self else { return }
            guard let connection = self.connection else { return }
            print("[remote-viewer] Disconnecting")
            self.isConnected = false
            self.isConnecting = false
            connection.cancel()
            self.cleanupConnection()
        }
    }
    
    private func cleanupConnection() {
        connection = nil
    }
    
    // MARK: - Receiving
    
    /// Main receiving loop: read frames indefinitely until connection closed or error.
    private func receiveLoop() {
        receiveNextFrameLength()
    }
    
    /// Read exactly 4 bytes for the frame length prefix.
    private func receiveNextFrameLength() {
        guard let connection = connection else { return }
        connection.receive(minimumIncompleteLength: 4, maximumLength: 4) { [weak self] data, context, isComplete, error in
            guard let self = self else { return }
            if let error = error {
                print("[remote-viewer] Receive error on length: \(error.localizedDescription)")
                self.handleReceiveFailure()
                return
            }
            guard let data = data, data.count == 4 else {
                print("[remote-viewer] Failed to read 4 bytes for length. Received \(data?.count ?? 0) bytes.")
                self.handleReceiveFailure()
                return
            }
            
            let length = UInt32(bigEndian: data.withUnsafeBytes { $0.load(as: UInt32.self) })
            if length == 0 || length > UInt32(self.maxPayloadSize) {
                print("[remote-viewer] Invalid frame length: \(length)")
                self.handleReceiveFailure()
                return
            }
            
            self.receiveFramePayload(length: Int(length))
        }
    }
    
    /// Read exactly `length` bytes for the frame payload.
    private func receiveFramePayload(length: Int) {
        guard let connection = connection else { return }
        connection.receive(minimumIncompleteLength: length, maximumLength: length) { [weak self] data, context, isComplete, error in
            guard let self = self else { return }
            if let error = error {
                print("[remote-viewer] Receive error on payload: \(error.localizedDescription)")
                self.handleReceiveFailure()
                return
            }
            guard let data = data, data.count == length else {
                print("[remote-viewer] Failed to read expected payload length: \(length). Received \(data?.count ?? 0) bytes.")
                self.handleReceiveFailure()
                return
            }
            
            #if canImport(AppKit)
            if let image = NSImage(data: data) {
                Task { @MainActor in
                    self.onFrameReceived?(image)
                }
            } else {
                print("[remote-viewer] Failed to decode image from frame payload")
            }
            #endif
            
            // Continue receiving next frame
            self.receiveNextFrameLength()
        }
    }
    
    private func handleReceiveFailure() {
        disconnect()
    }
    
    // MARK: - Sending
    
    /// Send JSON event framed with 4-byte big-endian length prefix.
    private func send(jsonObject: [String: Any]) {
        sendQueue.async { [weak self] in
            guard let self = self else { return }
            guard self.isConnected, let connection = self.connection else {
                print("[remote-viewer] Not connected, cannot send")
                return
            }
            
            do {
                let data = try JSONSerialization.data(withJSONObject: jsonObject, options: [])
                guard data.count <= self.maxPayloadSize else {
                    print("[remote-viewer] JSON message too large to send (\(data.count) bytes)")
                    return
                }
                
                var lengthPrefix = UInt32(data.count).bigEndian
                var lengthData = Data(bytes: &lengthPrefix, count: 4)
                lengthData.append(data)
                
                connection.send(content: lengthData, completion: .contentProcessed { sendError in
                    if let sendError = sendError {
                        print("[remote-viewer] Send error: \(sendError.localizedDescription)")
                    }
                })
            } catch {
                print("[remote-viewer] Failed to serialize JSON object: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - Public Control/Input Events
    
    /// Send a tap event at (x, y).
    /// JSON schema: { "type": "tap", "x": Double, "y": Double }
    public func sendTap(x: Double, y: Double) {
        let json: [String: Any] = [
            "type": "tap",
            "x": x,
            "y": y
        ]
        send(jsonObject: json)
    }
    
    /// Convenience overload accepting Int coordinates.
    public func sendTap(x: Int, y: Int) {
        sendTap(x: Double(x), y: Double(y))
    }
    
    /// Send a swipe event from (startX, startY) to (endX, endY).
    /// JSON schema: { "type": "swipe", "startX": Double, "startY": Double, "endX": Double, "endY": Double }
    public func sendSwipe(startX: Double, startY: Double, endX: Double, endY: Double) {
        let json: [String: Any] = [
            "type": "swipe",
            "startX": startX,
            "startY": startY,
            "endX": endX,
            "endY": endY
        ]
        send(jsonObject: json)
    }
    
    /// Convenience overload accepting Int coordinates.
    public func sendSwipe(startX: Int, startY: Int, endX: Int, endY: Int) {
        sendSwipe(startX: Double(startX), startY: Double(startY), endX: Double(endX), endY: Double(endY))
    }
    
    /// Send a text input event.
    /// JSON schema: { "type": "text", "text": String }
    public func sendText(_ text: String) {
        let json: [String: Any] = [
            "type": "text",
            "text": text
        ]
        send(jsonObject: json)
    }
    
    /// Send a key press event with a key code.
    /// JSON schema: { "type": "key", "keyCode": Int }
    public func sendKeyPress(keyCode: Int) {
        let json: [String: Any] = [
            "type": "key",
            "keyCode": keyCode
        ]
        send(jsonObject: json)
    }
    
    /// Send navigation event: back button.
    /// JSON schema: { "type": "nav", "action": "back" }
    public func sendBackButton() {
        let json: [String: Any] = [
            "type": "nav",
            "action": "back"
        ]
        send(jsonObject: json)
    }
    
    /// Send navigation event: home button.
    /// JSON schema: { "type": "nav", "action": "home" }
    public func sendHomeButton() {
        let json: [String: Any] = [
            "type": "nav",
            "action": "home"
        ]
        send(jsonObject: json)
    }
    
    /// Send navigation event: recent apps button.
    /// JSON schema: { "type": "nav", "action": "recents" }
    public func sendRecentApps() {
        let json: [String: Any] = [
            "type": "nav",
            "action": "recents"
        ]
        send(jsonObject: json)
    }
}
